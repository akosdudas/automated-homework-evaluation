{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Automated Homework Evaluation? \u00b6 At the Budapest University of Technology and Economics (BME) Faculty of Electrical Engineering and Informatics (VIK) , we use the techniques presented here for evaluating homework assignments in software development courses. This page documents the methods that I, the author, find useful and apply in my teaching profession. Automated Homework Evaluation is not a single software. Instead, it is a concept, or recipe if you will , that uses both cloud resources and custom-made software to achieve its goal. Problem statement \u00b6 At BME VIK, we teach hundreds of students each semester. There are courses with more than 500 students in the first two years of education. And even after, what we call, choosing a specialization (like a minor), we often have 150-200 students in one class. Handling student bodies of this size require considerable resources. Thus, what we seek is scalable education . Software engineering is about solving problems . There are lots of criteria for software, especially for good software. But first and foremost a software must work correctly . As educators of software engineers, we must teach students to solve the problems they will face. What better way is for them to write software that works? But then again, testing software for correct behavior is strenuous and time-consuming. Thus, enter modern technologies. Virtualization technologies and continuous integration systems have shown us that running tests and setting up environments to run them can be automated. Why not use these to test not only large-scale enterprise software but comparatively small software homework assignments? The idea, of course, is not new, and I do not claim to have figured this out first. The goals \u00b6 The goal I set is to target automated and semi-automated homework evaluation where students write software code. The primary goal is to assess the student's practical skills. These circumstances do not cover all kinds of performance evaluations in university education. These assessments complement others, such as writing midterm tests, filling out quizzes in Moodle, submitting papers on chosen theoretical topics, etc. While automating evaluation, the goal is not 100% automation. Student work must be verified manually too. Automation reduces the time spent on laborious and strenuous tasks, but it does not entirely replace manual work - nor should it. So what are the goals? Collect assignments easily with as little work for teachers as possible. Review the relevant parts of the submitted code with ease. See what the student has added or changed quickly. Automated early fail if minimum requirements are not met; e.g., code must compile, otherwise fail automatically without manual work. Identify common problems and report these automatically to the students. Provide feedback to the students as soon as possible. Do not wait for the submission deadline. Allow students to improve their results based on automated feedback. Teach the students that iteration is an essential part of software development. Code is not written once but polished and \"bug fixed\" as long as there are issues in it. Discuss the code with the students \"inside\" the source code. Show students how modern software development is carried out in teams, with code review and automation. Are these the right goals? These goals might not be universal. These goals apply to the way I, at BME VIK, teach specific software engineering classes. You can decide whether it applies to your use cases.","title":"What is Automated Homework Evaluation?"},{"location":"#what-is-automated-homework-evaluation","text":"At the Budapest University of Technology and Economics (BME) Faculty of Electrical Engineering and Informatics (VIK) , we use the techniques presented here for evaluating homework assignments in software development courses. This page documents the methods that I, the author, find useful and apply in my teaching profession. Automated Homework Evaluation is not a single software. Instead, it is a concept, or recipe if you will , that uses both cloud resources and custom-made software to achieve its goal.","title":"What is Automated Homework Evaluation?"},{"location":"#problem-statement","text":"At BME VIK, we teach hundreds of students each semester. There are courses with more than 500 students in the first two years of education. And even after, what we call, choosing a specialization (like a minor), we often have 150-200 students in one class. Handling student bodies of this size require considerable resources. Thus, what we seek is scalable education . Software engineering is about solving problems . There are lots of criteria for software, especially for good software. But first and foremost a software must work correctly . As educators of software engineers, we must teach students to solve the problems they will face. What better way is for them to write software that works? But then again, testing software for correct behavior is strenuous and time-consuming. Thus, enter modern technologies. Virtualization technologies and continuous integration systems have shown us that running tests and setting up environments to run them can be automated. Why not use these to test not only large-scale enterprise software but comparatively small software homework assignments? The idea, of course, is not new, and I do not claim to have figured this out first.","title":"Problem statement"},{"location":"#the-goals","text":"The goal I set is to target automated and semi-automated homework evaluation where students write software code. The primary goal is to assess the student's practical skills. These circumstances do not cover all kinds of performance evaluations in university education. These assessments complement others, such as writing midterm tests, filling out quizzes in Moodle, submitting papers on chosen theoretical topics, etc. While automating evaluation, the goal is not 100% automation. Student work must be verified manually too. Automation reduces the time spent on laborious and strenuous tasks, but it does not entirely replace manual work - nor should it. So what are the goals? Collect assignments easily with as little work for teachers as possible. Review the relevant parts of the submitted code with ease. See what the student has added or changed quickly. Automated early fail if minimum requirements are not met; e.g., code must compile, otherwise fail automatically without manual work. Identify common problems and report these automatically to the students. Provide feedback to the students as soon as possible. Do not wait for the submission deadline. Allow students to improve their results based on automated feedback. Teach the students that iteration is an essential part of software development. Code is not written once but polished and \"bug fixed\" as long as there are issues in it. Discuss the code with the students \"inside\" the source code. Show students how modern software development is carried out in teams, with code review and automation. Are these the right goals? These goals might not be universal. These goals apply to the way I, at BME VIK, teach specific software engineering classes. You can decide whether it applies to your use cases.","title":"The goals"},{"location":"examples/","text":"Show me an example! \u00b6 The hello world example \u00b6 The complete picture is demonstrated here: https://github.com/akosdudas/ahk-sample-studentsolution/pull/1 This GitHub pull request represents a homework submission with automated evaluation. The student receives a starter code and extends it to fulfill the required tasks. The code the student added is visible here . (This is, of course, a dummy example.) The automated evaluation reports the assessment in comments here and here . What do you see in this example? Submissions are \"handed in\" at a centralized location (GitHub). No emails, no zip files. The final changes of the source code are highlighted. The teacher can comment on the source code directly, and it will be visible to the student. GitHub Actions CI runs automated checks and fails the submission if minimum requirements are not met. Custom-made software evaluates the solution, assigns points, and reports errors. Students can re-submit an improved solution and get instant feedback again. Real-life examples \u00b6 Here are a couple of real-life scenarios in which my colleagues at BME VIK and I used the concept. Microsoft SQL Server server-side programming (stored procedures, triggers): students have to write SQL scripts which are then evaluated for correctness in MSSQL server (e.g., does the stored procedure perform the required action). ASP.NET Core WebApi application written in C# using Entity Framework for database access: students write a REST API which is tested automatically; the expected end-result is validated in the REST responses and in the database too. Microsoft SQL Server Integration Services ETL process: CSV input files are processed by executing the ETL process the student creates. The assessment checks the result in the target database. Elasticsearch queries and Kibana visualizations: students write queries in Elasticsearch (JSON files) and create visualizations in Kibana (exported as JSON). The files are verified for key content. C# class inheritance: students create a class inheritance structure to showcase properly using object-oriented concepts. The code is verified with Roslyn to check, for example, whether specific classes have the necessary interfaces. Windows Forms UI: students create a user interface, which is verified with Visual Studio Coded UI Tests, e.g., whether a button exists on Form, etc.","title":"Show me an example!"},{"location":"examples/#show-me-an-example","text":"","title":"Show me an example!"},{"location":"examples/#the-hello-world-example","text":"The complete picture is demonstrated here: https://github.com/akosdudas/ahk-sample-studentsolution/pull/1 This GitHub pull request represents a homework submission with automated evaluation. The student receives a starter code and extends it to fulfill the required tasks. The code the student added is visible here . (This is, of course, a dummy example.) The automated evaluation reports the assessment in comments here and here . What do you see in this example? Submissions are \"handed in\" at a centralized location (GitHub). No emails, no zip files. The final changes of the source code are highlighted. The teacher can comment on the source code directly, and it will be visible to the student. GitHub Actions CI runs automated checks and fails the submission if minimum requirements are not met. Custom-made software evaluates the solution, assigns points, and reports errors. Students can re-submit an improved solution and get instant feedback again.","title":"The hello world example"},{"location":"examples/#real-life-examples","text":"Here are a couple of real-life scenarios in which my colleagues at BME VIK and I used the concept. Microsoft SQL Server server-side programming (stored procedures, triggers): students have to write SQL scripts which are then evaluated for correctness in MSSQL server (e.g., does the stored procedure perform the required action). ASP.NET Core WebApi application written in C# using Entity Framework for database access: students write a REST API which is tested automatically; the expected end-result is validated in the REST responses and in the database too. Microsoft SQL Server Integration Services ETL process: CSV input files are processed by executing the ETL process the student creates. The assessment checks the result in the target database. Elasticsearch queries and Kibana visualizations: students write queries in Elasticsearch (JSON files) and create visualizations in Kibana (exported as JSON). The files are verified for key content. C# class inheritance: students create a class inheritance structure to showcase properly using object-oriented concepts. The code is verified with Roslyn to check, for example, whether specific classes have the necessary interfaces. Windows Forms UI: students create a user interface, which is verified with Visual Studio Coded UI Tests, e.g., whether a button exists on Form, etc.","title":"Real-life examples"},{"location":"prerequisites/","text":"Prerequisite for automated evaluation \u00b6 The first step in creating an automated evaluation assignment is determining whether a particular homework or project is suitable. Let me give you some pointers for what might work. Technology \u00b6 First and foremost, technology must be available to automatically and headlessly run the code submitted by the student. Most programming languages and databases, nowadays, offer this out of the box. E.g., you can easily compile C, C++, C#, Java, Ruby, Php, Go, etc., code and run them in a virtualized environment. Some operating systems might be prohibitive, though. While Windows, Linux, and OSX environments are easy targets (for example, GitHub Actions CI can run on either platform), other environments using dedicated hardware, like FPGA or mobile phone operating systems, might not be suitable. You need to find out whether you can write a script that can execute in a CI system. The tasks must enable automated checking \u00b6 Not every software-related assignment can be automatically assessed. Creative actions, such as designing an architecture, are, by their nature, up for interpretation. Similarly, checking the contents of an image is not feasible with reasonable efforts. Code writing assignments are a better fit, but even here, not all tasks will work out. The expected result must deterministic and must be available for access after execution. E.g., checking the database records' contents is good, but checking the memory state is probably too complicated. And the result (e.g., the outcome of executing the software, the return value of a method, the status code of an HTTP response, etc.) must be such that a few lines of code can determine its correctness. So how can you determine whether automated evaluation can work for you? Try to write a script or program to check the submission of a student. Imagine that you receive the submission file and then automate what you would check manually. Starter code \u00b6 Provide a starter code to enforce file names and folder structure. If you want to compile the code or run the executable, you must know the file names. Most modern IDEs provide an umbrella, like a project, solution, workspace, package, or similar item, to describe an environment. But even if there is no IDE for the chosen platform, you can create empty files with the required names. Providing Docker-based environments (i.e., a docker-compose.yml ) that provision the environment with a single command works too. The starter code is also helpful to define the environment specifically. Most IDEs and projects, packages, solutions, etc., contain a description of the build and runtime environment. E.g., are you using Python 3.6 or 3.8, .NET Framework 4.8, or .NET Core 3.1? These settings should go into the starter code. Detailed specification \u00b6 The tasks must be specified in detail and leave as little up for interpretation as possible. Some examples: If you want to check that the C# class has a method that does some action, the method's name must be specified. If the webserver must return a specified content, the URL where this content resides must be specified. If the task is to store data in a database, the table name and column names must be specified. Reflection Some languages offer leniency here. E.g., you can use reflection in C# to find a method in a class, even if the name is not known. Such techniques offer great possibilities. Specifications in real-life scenarios rarely provide the name of every method and field of a class. Therefore, the specification can be less strict when using reflection to \"find\" the code parts that need checking. Improved in iterations There is a single way the specification should be interpreted, but it will be misinterpreted in countless ways. Having hundreds of students \"checking\" your work will eventually help you word the specification precisely.","title":"Prerequisite for automated evaluation"},{"location":"prerequisites/#prerequisite-for-automated-evaluation","text":"The first step in creating an automated evaluation assignment is determining whether a particular homework or project is suitable. Let me give you some pointers for what might work.","title":"Prerequisite for automated evaluation"},{"location":"prerequisites/#technology","text":"First and foremost, technology must be available to automatically and headlessly run the code submitted by the student. Most programming languages and databases, nowadays, offer this out of the box. E.g., you can easily compile C, C++, C#, Java, Ruby, Php, Go, etc., code and run them in a virtualized environment. Some operating systems might be prohibitive, though. While Windows, Linux, and OSX environments are easy targets (for example, GitHub Actions CI can run on either platform), other environments using dedicated hardware, like FPGA or mobile phone operating systems, might not be suitable. You need to find out whether you can write a script that can execute in a CI system.","title":"Technology"},{"location":"prerequisites/#the-tasks-must-enable-automated-checking","text":"Not every software-related assignment can be automatically assessed. Creative actions, such as designing an architecture, are, by their nature, up for interpretation. Similarly, checking the contents of an image is not feasible with reasonable efforts. Code writing assignments are a better fit, but even here, not all tasks will work out. The expected result must deterministic and must be available for access after execution. E.g., checking the database records' contents is good, but checking the memory state is probably too complicated. And the result (e.g., the outcome of executing the software, the return value of a method, the status code of an HTTP response, etc.) must be such that a few lines of code can determine its correctness. So how can you determine whether automated evaluation can work for you? Try to write a script or program to check the submission of a student. Imagine that you receive the submission file and then automate what you would check manually.","title":"The tasks must enable automated checking"},{"location":"prerequisites/#starter-code","text":"Provide a starter code to enforce file names and folder structure. If you want to compile the code or run the executable, you must know the file names. Most modern IDEs provide an umbrella, like a project, solution, workspace, package, or similar item, to describe an environment. But even if there is no IDE for the chosen platform, you can create empty files with the required names. Providing Docker-based environments (i.e., a docker-compose.yml ) that provision the environment with a single command works too. The starter code is also helpful to define the environment specifically. Most IDEs and projects, packages, solutions, etc., contain a description of the build and runtime environment. E.g., are you using Python 3.6 or 3.8, .NET Framework 4.8, or .NET Core 3.1? These settings should go into the starter code.","title":"Starter code"},{"location":"prerequisites/#detailed-specification","text":"The tasks must be specified in detail and leave as little up for interpretation as possible. Some examples: If you want to check that the C# class has a method that does some action, the method's name must be specified. If the webserver must return a specified content, the URL where this content resides must be specified. If the task is to store data in a database, the table name and column names must be specified. Reflection Some languages offer leniency here. E.g., you can use reflection in C# to find a method in a class, even if the name is not known. Such techniques offer great possibilities. Specifications in real-life scenarios rarely provide the name of every method and field of a class. Therefore, the specification can be less strict when using reflection to \"find\" the code parts that need checking. Improved in iterations There is a single way the specification should be interpreted, but it will be misinterpreted in countless ways. Having hundreds of students \"checking\" your work will eventually help you word the specification precisely.","title":"Detailed specification"},{"location":"evaluate/","text":"Automated evaluation \u00b6 Automated evaluation of homework consists of the following steps: Write a program that tests the student's work. Obtain the student's work (i.e., download the code). Run the evaluation program. Publish the results of the evaluation. The key lies in automating as much as possible of this process . From a high level, I propose two alternatives: using GitHub and GitHub Actions as a platform for these steps, or performing them on your machine using software help . Before explaining these options, let us start with the first item: write the software for evaluation . This step, unfortunately, cannot be automated.","title":"Automated evaluation"},{"location":"evaluate/#automated-evaluation","text":"Automated evaluation of homework consists of the following steps: Write a program that tests the student's work. Obtain the student's work (i.e., download the code). Run the evaluation program. Publish the results of the evaluation. The key lies in automating as much as possible of this process . From a high level, I propose two alternatives: using GitHub and GitHub Actions as a platform for these steps, or performing them on your machine using software help . Before explaining these options, let us start with the first item: write the software for evaluation . This step, unfortunately, cannot be automated.","title":"Automated evaluation"},{"location":"evaluate/ahk-cli/","text":"Ahk Cli \u00b6 Ahk-cli is a console application written in .NET Core for executing the evaluation of homeworks locally on your machine based on containers. This application targets step 3 of the automated evaluation process : running the evaluation program on the student submissions. Using this application the process of evaluation is as follows. Write a program that tests the student's work. The program must be containerized; ahk-cli only works with containers. Download the students' work and place each of them into separate folders. (For example, use Classroom Assistant for the download.) Run the evaluation using ahk-cli and Docker. Publish the results of the evaluation. The outcome is an Excel sheet that you can further transform and publish/import. For more information, please refer to the description in the following repository: https://github.com/akosdudas/ahk-cli .","title":"Ahk Cli"},{"location":"evaluate/ahk-cli/#ahk-cli","text":"Ahk-cli is a console application written in .NET Core for executing the evaluation of homeworks locally on your machine based on containers. This application targets step 3 of the automated evaluation process : running the evaluation program on the student submissions. Using this application the process of evaluation is as follows. Write a program that tests the student's work. The program must be containerized; ahk-cli only works with containers. Download the students' work and place each of them into separate folders. (For example, use Classroom Assistant for the download.) Run the evaluation using ahk-cli and Docker. Publish the results of the evaluation. The outcome is an Excel sheet that you can further transform and publish/import. For more information, please refer to the description in the following repository: https://github.com/akosdudas/ahk-cli .","title":"Ahk Cli"},{"location":"evaluate/evaluator-software/","text":"Evaluator software \u00b6 To give you some ideas on how to write the evaluator application, let me walk you through a simplified example. The details presented here are particular to the .NET Core platform. However, this is merely an example. Other technologies are just as applicable to automated assessment. Among the examples there are evaluator applications written in Python and PowerShell. The sample task \u00b6 The task the students have to complete is to write an ASP.NET Core WebApi application that provides a REST Api with two operations: GET /api/sample/<identifier> Returns 400 Bad Request if the identifier is missing, Locates the item and returns its content with 200 OK or 404 NotFound. DELETE /api/sample/<identifier> : Deletes the item and returns 200 OK. Detailed specification Note, how the specification is explicit about the URLs and the expected return values. This is a must in order to be able to verify them. The two \"exercises\" are also independent of each other, so that they can be assessed one after the other. Starter code \u00b6 The starter code is provided to the student in this repository: https://github.com/akosdudas/ahk-sample-startercode . The repository contains: A Visual Studio solution file and project definition with configured .NET Core version and pre-defined packages. .gitignore file so that only source code is uploaded to the repository and binaries are not. neptun.txt : see here . A placeholder image file where the student is expected to upload a screenshot of the running application. The project skeleton contains the following setup: The entry point of the web application according to the .NET Core WebApi platform. A test controller that the evaluator application can use to determine if the web application has started correctly. A skeleton controller for the student to put their code. Evaluator application \u00b6 The evaluator application is a .NET Core web application itself. Using the same technology enables hosting the student's web application within the evaluator application. This is a .NET Core specific solution. An alternative would be to start the student's code and connect to it using HTTP as it is a web application. Why hosting the student's code within? There is an application written by the student that serves HTTP requests. It has a built-in web server. So, technically, we would only need to start the application and issue HTTP queries from our independent evaluator application for testing the HTTP-based queries. But in this case, we would not be able to see \"inside\" the application. Suppose you require the student to insert data received via HTTP request into a database. If the HTTP response to the insertion indicates success, how do you know whether the data is there in the database? There are two options. The first is to check the underlying database directly. The second one is to integrate with the .NET Core application written by the student and \"catch\" the requests from the C# code towards the database. Entity Framework Core, the de-facto database access technology for .NET Core, enables this by allowing us to subscribe to events, such as database command being executer or opening a database transaction. Hence the need to host the student's code within the tester application to subscribe to such events. The process of evaluation is as follows. The entry point of the application sets up \"tasks\" to execute. These are the assessments of \"separate\" exercises within the same assignment. There is also a pre-processing step defined here. The pre-processing step sets up the environment. It starts the web application based on the student's code and checks if the connection can be established. Each exercise is evaluated separately. e.g., the exercise for handling GET queries is assessed here . The results are gathered in memory and are written to a text file at the end. This will make sense for the GitHub Action-based feedback . The evaluator application is containerized, and the container will be the \"distribution platform.\" The container is built using a GitHub Action workflow according to the definition file and uploaded to GitHub Container Registry . Public code and container Both the evaluator application and the container are public for demonstration purposes only. I recommend not publishing these to the students in real-life. Alternative approach: unit tests \u00b6 The evaluator application in this example is independent of the students' code. An alternative option is to include the testing code into the starter code as unit tests. The downsides of using unit tests are the following: The students see explicitly what is being tested. When the evaluator application is independent and is not distributed to the students, they cannot \"optimize\" the solutions to fulfill the tests specifically. If there is an error in the evaluation logic, it is complicated to fix it. Including the evaluation login into the starter code means that the students will have copies of this logic, so making a change will not be possible afterward - at least, it will not be easy. The container-based distribution allows updating the evaluation logic by pushing a new version of the container to the registry. On the other hand, the advantages of the unit-test based approach are: Students being able to execute the tests locally. The automation of the evaluation is more straightforward than having to manage containers too.","title":"Evaluator software"},{"location":"evaluate/evaluator-software/#evaluator-software","text":"To give you some ideas on how to write the evaluator application, let me walk you through a simplified example. The details presented here are particular to the .NET Core platform. However, this is merely an example. Other technologies are just as applicable to automated assessment. Among the examples there are evaluator applications written in Python and PowerShell.","title":"Evaluator software"},{"location":"evaluate/evaluator-software/#the-sample-task","text":"The task the students have to complete is to write an ASP.NET Core WebApi application that provides a REST Api with two operations: GET /api/sample/<identifier> Returns 400 Bad Request if the identifier is missing, Locates the item and returns its content with 200 OK or 404 NotFound. DELETE /api/sample/<identifier> : Deletes the item and returns 200 OK. Detailed specification Note, how the specification is explicit about the URLs and the expected return values. This is a must in order to be able to verify them. The two \"exercises\" are also independent of each other, so that they can be assessed one after the other.","title":"The sample task"},{"location":"evaluate/evaluator-software/#starter-code","text":"The starter code is provided to the student in this repository: https://github.com/akosdudas/ahk-sample-startercode . The repository contains: A Visual Studio solution file and project definition with configured .NET Core version and pre-defined packages. .gitignore file so that only source code is uploaded to the repository and binaries are not. neptun.txt : see here . A placeholder image file where the student is expected to upload a screenshot of the running application. The project skeleton contains the following setup: The entry point of the web application according to the .NET Core WebApi platform. A test controller that the evaluator application can use to determine if the web application has started correctly. A skeleton controller for the student to put their code.","title":"Starter code"},{"location":"evaluate/evaluator-software/#evaluator-application","text":"The evaluator application is a .NET Core web application itself. Using the same technology enables hosting the student's web application within the evaluator application. This is a .NET Core specific solution. An alternative would be to start the student's code and connect to it using HTTP as it is a web application. Why hosting the student's code within? There is an application written by the student that serves HTTP requests. It has a built-in web server. So, technically, we would only need to start the application and issue HTTP queries from our independent evaluator application for testing the HTTP-based queries. But in this case, we would not be able to see \"inside\" the application. Suppose you require the student to insert data received via HTTP request into a database. If the HTTP response to the insertion indicates success, how do you know whether the data is there in the database? There are two options. The first is to check the underlying database directly. The second one is to integrate with the .NET Core application written by the student and \"catch\" the requests from the C# code towards the database. Entity Framework Core, the de-facto database access technology for .NET Core, enables this by allowing us to subscribe to events, such as database command being executer or opening a database transaction. Hence the need to host the student's code within the tester application to subscribe to such events. The process of evaluation is as follows. The entry point of the application sets up \"tasks\" to execute. These are the assessments of \"separate\" exercises within the same assignment. There is also a pre-processing step defined here. The pre-processing step sets up the environment. It starts the web application based on the student's code and checks if the connection can be established. Each exercise is evaluated separately. e.g., the exercise for handling GET queries is assessed here . The results are gathered in memory and are written to a text file at the end. This will make sense for the GitHub Action-based feedback . The evaluator application is containerized, and the container will be the \"distribution platform.\" The container is built using a GitHub Action workflow according to the definition file and uploaded to GitHub Container Registry . Public code and container Both the evaluator application and the container are public for demonstration purposes only. I recommend not publishing these to the students in real-life.","title":"Evaluator application"},{"location":"evaluate/evaluator-software/#alternative-approach-unit-tests","text":"The evaluator application in this example is independent of the students' code. An alternative option is to include the testing code into the starter code as unit tests. The downsides of using unit tests are the following: The students see explicitly what is being tested. When the evaluator application is independent and is not distributed to the students, they cannot \"optimize\" the solutions to fulfill the tests specifically. If there is an error in the evaluation logic, it is complicated to fix it. Including the evaluation login into the starter code means that the students will have copies of this logic, so making a change will not be possible afterward - at least, it will not be easy. The container-based distribution allows updating the evaluation logic by pushing a new version of the container to the registry. On the other hand, the advantages of the unit-test based approach are: Students being able to execute the tests locally. The automation of the evaluation is more straightforward than having to manage containers too.","title":"Alternative approach: unit tests"},{"location":"evaluate/github-actions/","text":"GitHub Actions \u00b6 GitHub Actions is a continuous integration (CI) platform offering from GitHub. It enables the definition of so-called workflows executed in an environment managed by GitHub. We can use the workflow to define our assessment tasks if the students submit their solutions in GitHub repositories . Why GitHub Actions? Mainly because using GitHub enables us to cover multiple steps of the homework submission-evaluation process. Don't want to or cannot use GitHub? Check out the alternative option here . Running the evaluation \u00b6 The pre-requisites of running the evaluation in GitHub are the following. You need a GitHub organization with GitHub Education benefits providing you with free credits for executing Actions in the cloud. Have the students submit their work in GitHub . Include a workflow definition in the starter code repository specifying the assessment process. The workflow definition is a yaml file placed in the starter code repository. When the student's repository is created, the contents, along with the workflow definition, are copied from the starer repository. Here are two sample workflow definitions. Example 1 \u00b6 The first example is from the presented sample at https://github.com/akosdudas/ahk-sample-startercode/blob/master/.github/workflows/evaluate.yml . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 name : Evaluation on : pull_request : types : [ opened , synchronize , ready_for_review , labeled ] jobs : evaluate : runs-on : ubuntu-latest timeout-minutes : 3 if : github.event.pull_request.draft == false steps : - name : Checkout uses : actions/checkout@v2 with : fetch-depth : 1 - name : Check neptun.txt uses : akosdudas/ahk-action-neptuncheck@v1 - name : Prepare .NET SDK uses : actions/setup-dotnet@v1 with : dotnet-version : \"2.1.607\" - name : Build sln run : dotnet build - name : Evaluate uses : docker://ghcr.io/akosdudas/ahk-sample:evaluator-v1 - name : Publish results uses : docker://ghcr.io/akosdudas/ahk-publish-results-pr:v1 with : GITHUB_TOKEN : \"${{ secrets.GITHUB_TOKEN }}\" AHK_IMAGEEXT : \".png\" AHK_RESULTFILE : \"result.txt\" This workflow definition works on pull requests ; this is what you see on lines 4-5. If the student sets the pull request as draft , the evaluation is skipped (line 13), allowing the student to make changes to the code without running the assessment. Since the evaluator application is containerized, the Ubuntu virtual environment is used for the CI execution (line 9). (GitHub also has Windows and macOS environments.) Specifying a timeout (line 11) prohibits long-running workflows, which would only eat up the minutes available in GitHub; the evaluation should not take more than a minute, including obtaining the source code and pulling container images. The assessment starts in line 16 with the checkout of the source code (to get the student's code). Next, there is a preliminary check verifying the existence of a text file that contains the student's identifier; see the reason here . If the student forgot to upload this file, the assessment does not proceed. The next step is building the source code to get the executable versions (lines 24-30). If the build fails, the student is automatically notified. And now comes the actual assessment. Since the evaluator application is containerized, the workflow only needs to trigger the execution of this container. The working directory with the source code and the built binaries are mounted into the container, so the application can access it. The final step is publishing the results of the assessment (line 35). The evaluator application writes the results to a text file, and the custom containerized application reads this text file to send the contents into the pull request thread ( see example here ). (This custom step also allows us to save the outcome of the automated evaluation to a database, which reduces the manual labor on the part of the instructors; see here for further details.) Example 2 \u00b6 The second example simplifies the process by eliminating the pull request and the container too. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 name : Evaluation on : [ push ] jobs : build : runs-on : ubuntu-latest timeout-minutes : 3 steps : - name : Checkout uses : actions/checkout@v1 - name : Check neptun.txt uses : akosdudas/ahk-action-neptuncheck@v1 - name : Prepare .NET SDK uses : actions/setup-dotnet@v1 with : dotnet-version : \"5.0.200\" - name : Build .NET code run : dotnet build - name : Run .NET unit tests run : dotnet test Suppose you distribute the evaluator code as unit tests . In that case, you can run them with a simple command (line 27) after preparing the appropriate SDK and building the code (lines 18-24). There are no pull requests here either. The trigger for evaluation is a push (line 3), so every time the student pushed code to the GitHub repository, this workflow will execute. The results will be limited to console output of the process on GitHub's web interface . Tips \u00b6 A few tips to keep in mind when using this approach. Keep the workflow file universal and straightforward. The workflow definition file is copied to the student's repository. You cannot make changes to it. The file must be \"universal,\" that is, changes you might need to make in the evaluation process should not be part of this file. Containerizing the evaluator application is an excellent way of ensuring that the workflow file needs no change; any update to the assessment process happens in the container, which you can update. Limit the number of evaluations. Be explicit about how many executions students are allowed. The assessment takes time and consumes the minutes you have in GitHub. The students should not use this online assessment to verify their work every step of the way. The automated evaluation should be the last step in the process after they checked their work locally. But do not limit it to one. This method aims to enable the student to correct the code if something does not work according to expectations. Prepare for occasional outages. There are far too many moving parts in this process. Sometimes things will break. GitHub Actions has outages sometimes; pulling containers fail occasionally; the execution times out from time to time; the .NET SDK download fails randomly; etc. These things happen. Either prepare to help students through transient errors (i.e., by manually re-running the failed workflow ), or let them know how to do this on their own. Set up a self-hosted runner if the free CI minutes are not enough or you need specialized software/hardware. GitHub allows you to use self-hosted runners instead of the ones provided in the cloud. You can prepare your customized environment in these runners. But before going down this path, also consider that you will need stable infrastructure and monitoring to do this.","title":"GitHub Actions"},{"location":"evaluate/github-actions/#github-actions","text":"GitHub Actions is a continuous integration (CI) platform offering from GitHub. It enables the definition of so-called workflows executed in an environment managed by GitHub. We can use the workflow to define our assessment tasks if the students submit their solutions in GitHub repositories . Why GitHub Actions? Mainly because using GitHub enables us to cover multiple steps of the homework submission-evaluation process. Don't want to or cannot use GitHub? Check out the alternative option here .","title":"GitHub Actions"},{"location":"evaluate/github-actions/#running-the-evaluation","text":"The pre-requisites of running the evaluation in GitHub are the following. You need a GitHub organization with GitHub Education benefits providing you with free credits for executing Actions in the cloud. Have the students submit their work in GitHub . Include a workflow definition in the starter code repository specifying the assessment process. The workflow definition is a yaml file placed in the starter code repository. When the student's repository is created, the contents, along with the workflow definition, are copied from the starer repository. Here are two sample workflow definitions.","title":"Running the evaluation"},{"location":"evaluate/github-actions/#example-1","text":"The first example is from the presented sample at https://github.com/akosdudas/ahk-sample-startercode/blob/master/.github/workflows/evaluate.yml . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 name : Evaluation on : pull_request : types : [ opened , synchronize , ready_for_review , labeled ] jobs : evaluate : runs-on : ubuntu-latest timeout-minutes : 3 if : github.event.pull_request.draft == false steps : - name : Checkout uses : actions/checkout@v2 with : fetch-depth : 1 - name : Check neptun.txt uses : akosdudas/ahk-action-neptuncheck@v1 - name : Prepare .NET SDK uses : actions/setup-dotnet@v1 with : dotnet-version : \"2.1.607\" - name : Build sln run : dotnet build - name : Evaluate uses : docker://ghcr.io/akosdudas/ahk-sample:evaluator-v1 - name : Publish results uses : docker://ghcr.io/akosdudas/ahk-publish-results-pr:v1 with : GITHUB_TOKEN : \"${{ secrets.GITHUB_TOKEN }}\" AHK_IMAGEEXT : \".png\" AHK_RESULTFILE : \"result.txt\" This workflow definition works on pull requests ; this is what you see on lines 4-5. If the student sets the pull request as draft , the evaluation is skipped (line 13), allowing the student to make changes to the code without running the assessment. Since the evaluator application is containerized, the Ubuntu virtual environment is used for the CI execution (line 9). (GitHub also has Windows and macOS environments.) Specifying a timeout (line 11) prohibits long-running workflows, which would only eat up the minutes available in GitHub; the evaluation should not take more than a minute, including obtaining the source code and pulling container images. The assessment starts in line 16 with the checkout of the source code (to get the student's code). Next, there is a preliminary check verifying the existence of a text file that contains the student's identifier; see the reason here . If the student forgot to upload this file, the assessment does not proceed. The next step is building the source code to get the executable versions (lines 24-30). If the build fails, the student is automatically notified. And now comes the actual assessment. Since the evaluator application is containerized, the workflow only needs to trigger the execution of this container. The working directory with the source code and the built binaries are mounted into the container, so the application can access it. The final step is publishing the results of the assessment (line 35). The evaluator application writes the results to a text file, and the custom containerized application reads this text file to send the contents into the pull request thread ( see example here ). (This custom step also allows us to save the outcome of the automated evaluation to a database, which reduces the manual labor on the part of the instructors; see here for further details.)","title":"Example 1"},{"location":"evaluate/github-actions/#example-2","text":"The second example simplifies the process by eliminating the pull request and the container too. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 name : Evaluation on : [ push ] jobs : build : runs-on : ubuntu-latest timeout-minutes : 3 steps : - name : Checkout uses : actions/checkout@v1 - name : Check neptun.txt uses : akosdudas/ahk-action-neptuncheck@v1 - name : Prepare .NET SDK uses : actions/setup-dotnet@v1 with : dotnet-version : \"5.0.200\" - name : Build .NET code run : dotnet build - name : Run .NET unit tests run : dotnet test Suppose you distribute the evaluator code as unit tests . In that case, you can run them with a simple command (line 27) after preparing the appropriate SDK and building the code (lines 18-24). There are no pull requests here either. The trigger for evaluation is a push (line 3), so every time the student pushed code to the GitHub repository, this workflow will execute. The results will be limited to console output of the process on GitHub's web interface .","title":"Example 2"},{"location":"evaluate/github-actions/#tips","text":"A few tips to keep in mind when using this approach. Keep the workflow file universal and straightforward. The workflow definition file is copied to the student's repository. You cannot make changes to it. The file must be \"universal,\" that is, changes you might need to make in the evaluation process should not be part of this file. Containerizing the evaluator application is an excellent way of ensuring that the workflow file needs no change; any update to the assessment process happens in the container, which you can update. Limit the number of evaluations. Be explicit about how many executions students are allowed. The assessment takes time and consumes the minutes you have in GitHub. The students should not use this online assessment to verify their work every step of the way. The automated evaluation should be the last step in the process after they checked their work locally. But do not limit it to one. This method aims to enable the student to correct the code if something does not work according to expectations. Prepare for occasional outages. There are far too many moving parts in this process. Sometimes things will break. GitHub Actions has outages sometimes; pulling containers fail occasionally; the execution times out from time to time; the .NET SDK download fails randomly; etc. These things happen. Either prepare to help students through transient errors (i.e., by manually re-running the failed workflow ), or let them know how to do this on their own. Set up a self-hosted runner if the free CI minutes are not enough or you need specialized software/hardware. GitHub allows you to use self-hosted runners instead of the ones provided in the cloud. You can prepare your customized environment in these runners. But before going down this path, also consider that you will need stable infrastructure and monitoring to do this.","title":"Tips"},{"location":"others/archival/","text":"Archival of student work \u00b6 Once a semester is completed, you will need to archive the course's materials. These are the steps I take. Disable the invitation link in GitHub Classroom. When you set up the assignments , you get an invitation link to share with the students. These links should be disabled as soon as the submission deadline passes to prohibit abusing the link. Download all assignments from GitHub. Use Classroom assistant to download all repositories from GitHub and archive them according to your institution's policy. Archive the classroom itself on GitHub Classroom's website. This operation does nothing to the underlying content, but it will be explicit that this classroom is no longer used. Archive each student repository. To prohibit any modifications to the repositories, it is best to make them read-only by archiving them. Archiving the classroom (previous step) does not touch the repositories, so it must be performed manually. I use a short script to do this. You will need a personal access token from GitHub. // This is C# code using the official Octokit NuGet package string token = @\"<your personal access token>\" ; var gitHubClient = new GitHubClient ( new ProductHeaderValue ( \"<any text>\" ), new InMemoryCredentialStore ( new Credentials ( token ))); while ( true ) { // add your organization name and the repository prefix here var searchResult = await gitHubClient . Search . SearchRepo ( new SearchRepositoriesRequest ( $\"org:<org-name> archived:false <repo-prefix>\" )); if ( searchResult . Items . Count == 0 ) break ; foreach ( var repo in searchResult . Items ) { await gitHubClient . Repository . Edit ( repo . Id , new RepositoryUpdate ( repo . Name ) { Archived = true }); Console . WriteLine ( repo . FullName ); } // looks like archive is async, and a repository is returned again // in the next search phase after archive is started await Task . Delay ( TimeSpan . FromSeconds ( 60 )); } Alternative to archival: delete the classroom . You probably should not do this right after the semester ends, but maybe after a year or so. Deleting the classroom also deletes the repositories from the organization!","title":"Archival of student work"},{"location":"others/archival/#archival-of-student-work","text":"Once a semester is completed, you will need to archive the course's materials. These are the steps I take. Disable the invitation link in GitHub Classroom. When you set up the assignments , you get an invitation link to share with the students. These links should be disabled as soon as the submission deadline passes to prohibit abusing the link. Download all assignments from GitHub. Use Classroom assistant to download all repositories from GitHub and archive them according to your institution's policy. Archive the classroom itself on GitHub Classroom's website. This operation does nothing to the underlying content, but it will be explicit that this classroom is no longer used. Archive each student repository. To prohibit any modifications to the repositories, it is best to make them read-only by archiving them. Archiving the classroom (previous step) does not touch the repositories, so it must be performed manually. I use a short script to do this. You will need a personal access token from GitHub. // This is C# code using the official Octokit NuGet package string token = @\"<your personal access token>\" ; var gitHubClient = new GitHubClient ( new ProductHeaderValue ( \"<any text>\" ), new InMemoryCredentialStore ( new Credentials ( token ))); while ( true ) { // add your organization name and the repository prefix here var searchResult = await gitHubClient . Search . SearchRepo ( new SearchRepositoriesRequest ( $\"org:<org-name> archived:false <repo-prefix>\" )); if ( searchResult . Items . Count == 0 ) break ; foreach ( var repo in searchResult . Items ) { await gitHubClient . Repository . Edit ( repo . Id , new RepositoryUpdate ( repo . Name ) { Archived = true }); Console . WriteLine ( repo . FullName ); } // looks like archive is async, and a repository is returned again // in the next search phase after archive is started await Task . Delay ( TimeSpan . FromSeconds ( 60 )); } Alternative to archival: delete the classroom . You probably should not do this right after the semester ends, but maybe after a year or so. Deleting the classroom also deletes the repositories from the organization!","title":"Archival of student work"},{"location":"others/individual-work/","text":"Ensuring individual work \u00b6 Assessing homework assignments has to assign a grade of some sort and determine whether the student completed the task alone. Various policies apply to individual work, and students in our higher education institutions comply with these policies with varying strictness. How can you ensure that the work submitted by the student will be their work? First, what are the downsides of using automated evaluation? Since the task description should be specific down to how to call methods, it will lead to slight variance in code. Using plagiarism detection, therefore, will not work. This is a known cost for being able to automate the evaluation. So what can you do? This question alone is worth an essay in itself, so let me highlight some ideas that my colleagues and I are applying. Ask the students to add comments into the code explaining the behavior. Request the student to create and submit screenshots that showcase some parts of the software. Have them display a unique identifier on these screenshots (e.g., add the student ID into the URL, display the student name in the footer of a website, prefix all database records with their name, etc.). Request students to present their homework to you (or at least some parts if there are multiple ones) personally and ask for a minor modification in the code. Combine the homework with other evaluation methods where cheating is not feasible.","title":"Ensuring individual work"},{"location":"others/individual-work/#ensuring-individual-work","text":"Assessing homework assignments has to assign a grade of some sort and determine whether the student completed the task alone. Various policies apply to individual work, and students in our higher education institutions comply with these policies with varying strictness. How can you ensure that the work submitted by the student will be their work? First, what are the downsides of using automated evaluation? Since the task description should be specific down to how to call methods, it will lead to slight variance in code. Using plagiarism detection, therefore, will not work. This is a known cost for being able to automate the evaluation. So what can you do? This question alone is worth an essay in itself, so let me highlight some ideas that my colleagues and I are applying. Ask the students to add comments into the code explaining the behavior. Request the student to create and submit screenshots that showcase some parts of the software. Have them display a unique identifier on these screenshots (e.g., add the student ID into the URL, display the student name in the footer of a website, prefix all database records with their name, etc.). Request students to present their homework to you (or at least some parts if there are multiple ones) personally and ask for a minor modification in the code. Combine the homework with other evaluation methods where cheating is not feasible.","title":"Ensuring individual work"},{"location":"using-github/","text":"Using GitHub \u00b6 GitHub is a very well-known entity for software developers. It is the de-facto place for open-source software, and it offers convenient tools for us, educators too. This is not an ad I am in no way affiliated with GitHub or Microsoft (the owner of GitHub). This website is not an advertisement to make you use GitHub. The ideas and techniques presented here are merely a description of a technology that efficiently automates homework assessment. GitHub organization \u00b6 When planning on using GitHub, you will need to create a GitHub organization for your course. The organization is an umbrella entity to store your class's GitHub content. The organization is also the point of access control, e.g., to allow teaching assistants or team teachers to perform specific tasks. Here is one of my organizations: https://github.com/bmeviauac01/ . The organization has a landing page with a name and the most important repositories pinned: Organization name I recommend using course codes for the organization name. Do not call the organization \"prog101\"; instead, call it \"bmeviauac01\" (this is a course code at BME VIK). Use a lowercase name as the name will be part of the URL. Re-using GitHub organizations You might not need a separate GitHub organization for all your courses. Your university, faculty, or department might already have an organization. You can re-use these organizations, but mind the drawbacks: When using GitHub Classroom you will need a dedicated organization. First, because you need to be an owner of an organization to use GitHub Classroom. And second, GitHub Classroom will create lots of repositories for the student assignments, and you don't want the repositories of various classes being mixed up. Controlling access inside the organization is centralized. Suppose you want to allow a teaching assistant to see and edit content. In that case, you must assign the appropriate role in the organization, which applies to all content in the organization, not just your class.","title":"Using GitHub"},{"location":"using-github/#using-github","text":"GitHub is a very well-known entity for software developers. It is the de-facto place for open-source software, and it offers convenient tools for us, educators too. This is not an ad I am in no way affiliated with GitHub or Microsoft (the owner of GitHub). This website is not an advertisement to make you use GitHub. The ideas and techniques presented here are merely a description of a technology that efficiently automates homework assessment.","title":"Using GitHub"},{"location":"using-github/#github-organization","text":"When planning on using GitHub, you will need to create a GitHub organization for your course. The organization is an umbrella entity to store your class's GitHub content. The organization is also the point of access control, e.g., to allow teaching assistants or team teachers to perform specific tasks. Here is one of my organizations: https://github.com/bmeviauac01/ . The organization has a landing page with a name and the most important repositories pinned: Organization name I recommend using course codes for the organization name. Do not call the organization \"prog101\"; instead, call it \"bmeviauac01\" (this is a course code at BME VIK). Use a lowercase name as the name will be part of the URL. Re-using GitHub organizations You might not need a separate GitHub organization for all your courses. Your university, faculty, or department might already have an organization. You can re-use these organizations, but mind the drawbacks: When using GitHub Classroom you will need a dedicated organization. First, because you need to be an owner of an organization to use GitHub Classroom. And second, GitHub Classroom will create lots of repositories for the student assignments, and you don't want the repositories of various classes being mixed up. Controlling access inside the organization is centralized. Suppose you want to allow a teaching assistant to see and edit content. In that case, you must assign the appropriate role in the organization, which applies to all content in the organization, not just your class.","title":"GitHub organization"},{"location":"using-github/collecting-submissions/","text":"Collecting submissions \u00b6 You need a place to collect the submitted assignments. Source code consists of multiple files; thus, it is usually zipped and uploaded somewhere (e.g., Moodle assignment) as a file. Working with zip files is inconvenient: it has to be downloaded, extracted, opened in a specific tool, like an IDE, the files opened inside the IDE, the entire source compiled, etc. All these steps are error-prone (\"who was the student that this zip belongs to?\"), manual and laborious (clicking a lot), and not very safe (opening files from not exactly trusted sources; just remember the zip slip vulnerability .) GitHub Classroom \u00b6 GitHub Classroom is a tool built into GitHub that automates collecting submissions. Suppose you want the students to submit the assignment in git repositories. You would need to create a repository for each student, add yourself and other teachers to the repository, add the student to the repository, import the starter code, and send the link to the student. This process is precisely what GitHub Classroom does. Once you have a GitHub organization , you can use the organization to \"collect\" all the git repositories from your students. The students will not own the repositories; the organization will own them , and the students are added to the repositories (only their repositories) as collaborators. Teachers and yourself will be able to access all of these repositories just by being part of the organization. Set up GitHub Classroom \u00b6 Setting up GitHub Classroom consist of steps you need to perform once, and steps that you will need to repeat each semester. Create the GitHub organization if you don't have one yet. See recommendations here . Add other teachers to this organization as members. These members will be able to access specified content within the organization. Configure the base permission inside the organization. This permission determines whether organization members (theses are the teachers and not the students) have access to the students' submissions. Set the base permission to read so that every organization member (again, these are your teachers) can read all repositories to check student submissions. Or set the base permission to write to enable organization members to contribute to the students' repositories. Contribution means being able to add comments to the source code or merge pull requests. Sign up for GitHub Education benefits. If you teach at an academic institution, this is free after verifying your status. This process (as of today) consists of two steps: verify your status and then upgrade your GitHub organization to have the benefits applied. GitHub Education is not necessarily required. GitHub (again, as of today) offers organizations and public repositories free of charge. But if you want private repositories, you need to pay for it - or request the discount. Private repositories are useful so that students do not see each other's work. Open GitHub Classroom , sign-in, and create a new classroom . A classroom can be, for example, your Programming databases 2021 spring course. Classroom per course and per semester The classroom provides you with a level of organization. Create a new classroom each semester, and archive old classrooms. When creating the classroom , you will be offered to create a roster . The problem the roster tries to solve is the mapping of students to repositories. Careful with the roster Identifiers, like names or student ID numbers, are considered sensitive information and should not be published in the roster! In the European Union, the GDPR is quite strict about such matters. Therefore, you should make sure whether using a roster is possible for you. Check the alternative method proposed below. Inside the classroom , create as many assignments as you need. Create one for each homework. Each assignment has a name and a repository name prefix. The repository name prefix will be used when the student's repository is created. Make sure to provide a meaningful name; i.e., \"homework\" will not be enough. Assignment names and repository prefixes A recommended assignment name, for example, is \"Microsoft SQL Server programming\" or \"Homework 1 Java\". The repository name prefix should include: a short prefix to separate these repositories from all others, e.g., \"hw\", the year or semester, and the short name of the assignment. This prefix will be postfixed with the student's GitHub account name, so it will look like this: hw-2021-mssql-tinystar774 . This is how one of my classrooms look like: The assignment will enable you to specify a starter code template repository . This repository will be used to populate the newly created repository for the student. This template repository is your starter code . Finally, note the assignment's invitation URL . This is the link you should communicate to your students. The invitation URL should not be public This URL will enable anyone to create a repository in your organization. Do not publish it on a public website. I have seen a public invitation URL being abused, resulting in the entire GitHub organization being disabled. How does all this help you? \u00b6 Students need only click the invitation link (see below), and their own personal repository will be created for them. There is no room for error here. Members of the organization will have access to all submission repositories , while students only see their personal repository. You can control access by adding teachers to the organization as members. The starter code is automatically copied into the student's repository. Automating this step is also useful to avoid questions and problems, such as students not finding the download link to the starter code, corrupted downloads, not being able to extract a file due to not having A or B compression tool installed, messing up file names with special characters or spaces in the name, creating an extra unnecessary directory after extracting an archive, etc. (Add your favorite \"how did this happen, really?\" anecdote in here.) You do not need to download students' code or extract it. The source code is available inside a web browser and you can review it with ease. For more details, see Using pull requests . Not using a student roster \u00b6 Students get dedicated repositories in GitHub. The problem you will face is to map the repositories to students. The names of the repositories will contain the GitHub user names of students, but that will not be enough. The student roster of GitHub helps this by mapping the student's name to the repository, but it will not change the repository names. Thus it will still be complicated to find the repository for a student. Not to mention the previously noted privacy issues. Instead of the roster, I recommend two other approaches. Option 1: Adding the student identifier to a specified text file in the repository \u00b6 Add a dedicated empty text file into the starter code repository into which the students must type their unique ID number. E.g., my university, BME, assigns a so-called Neptun-code to everyone. Thus, I add an empty neptun.txt into the root of the starter code repository , and the assignment instructions tell the students to type their code into this file. There are simple benefits to this solution. First, the mapping of the student with the repository exists inside the repository. If I see a repository, I can check whom it belongs to by checking the file contents. Second, GitHub has extensive search capabilities. I can find the repository of a student by executing a search within the organization, which will match the contents of these text files too. And finally, automation can check the existence of this text file and its content. GitHub has a continuous integration system, called GitHub Actions , enabling us to execute scripts on the student repositories automatically. For example, you can check the text file upon each commit and report an error to the student when there is a problem. An example for such action is available here: https://github.com/akosdudas/ahk-action-neptuncheck . This is a GitHub Action specification, which can be included in a workflow . Customized checking This action requires a specific file name and content. Feel free to reuse it or fork it and create your own! Option 2: Registering repository names in a Microsoft Form or Google Forms \u00b6 You can publish a registration form using Microsoft Forms or Google Forms and ask your students to add their repository URL along with their student ID number. This solution is simple but error-prone if students forget this. Plus, you will not have the search capability as in the previous option. Classroom Assistant \u00b6 Once you have the student repositories \"in the cloud,\" i.e., in GitHub, how do you work with them? One option is using pull requests , and the other one is to download them to your machine. I download the repositories for archival purposes at the end of the semester. How do you download hundreds of repositories? GitHub Classroom Assistant is a handy tool that enables mass download of all repositories of a Classroom assignment. I have been using this tool to download up to 250 repositories per assignment. Another way for mass download is scripting with the help of PowerShellForGitHub PowerShell Module . Since all repositories created by Classroom have an identical prefix, you can search for these repositories and clone them all in a script. Downsides of using GitHub Classroom \u00b6 GitHub and GitHub Classroom is not a universal solution for all. There are drawbacks and downsides of the techniques presented here. Without going into further details, here is a short list for consideration. Requires a GitHub account. It is free, though, but still asks the student to use a third-party service. Working with git is not always easy. The trivial tasks are simple, but once we get to branching, it tends to get complicated for students who don't have much practice with it. I recommend using good git clients, like GitHub Desktop , and promoting these to students too. There are occasional downtimes at GitHub. Like all cloud services, there are unexpected errors from time to time. In the past years, I have seen students experience intermittent errors dozens of times. It even prohibited us from completing a class once. You need a communication platform (Microsoft Teams, Slack channel, email list, etc.) to let students know when something is not working. Not all of them are experienced enough to recognize a real problem and to know when just a retry is needed. GitHub has its own terminology, like branches and pull requests. But we need assignments and submissions. You have to accept the fact that there is a misalignment here.","title":"Collecting submissions"},{"location":"using-github/collecting-submissions/#collecting-submissions","text":"You need a place to collect the submitted assignments. Source code consists of multiple files; thus, it is usually zipped and uploaded somewhere (e.g., Moodle assignment) as a file. Working with zip files is inconvenient: it has to be downloaded, extracted, opened in a specific tool, like an IDE, the files opened inside the IDE, the entire source compiled, etc. All these steps are error-prone (\"who was the student that this zip belongs to?\"), manual and laborious (clicking a lot), and not very safe (opening files from not exactly trusted sources; just remember the zip slip vulnerability .)","title":"Collecting submissions"},{"location":"using-github/collecting-submissions/#github-classroom","text":"GitHub Classroom is a tool built into GitHub that automates collecting submissions. Suppose you want the students to submit the assignment in git repositories. You would need to create a repository for each student, add yourself and other teachers to the repository, add the student to the repository, import the starter code, and send the link to the student. This process is precisely what GitHub Classroom does. Once you have a GitHub organization , you can use the organization to \"collect\" all the git repositories from your students. The students will not own the repositories; the organization will own them , and the students are added to the repositories (only their repositories) as collaborators. Teachers and yourself will be able to access all of these repositories just by being part of the organization.","title":"GitHub Classroom"},{"location":"using-github/collecting-submissions/#set-up-github-classroom","text":"Setting up GitHub Classroom consist of steps you need to perform once, and steps that you will need to repeat each semester. Create the GitHub organization if you don't have one yet. See recommendations here . Add other teachers to this organization as members. These members will be able to access specified content within the organization. Configure the base permission inside the organization. This permission determines whether organization members (theses are the teachers and not the students) have access to the students' submissions. Set the base permission to read so that every organization member (again, these are your teachers) can read all repositories to check student submissions. Or set the base permission to write to enable organization members to contribute to the students' repositories. Contribution means being able to add comments to the source code or merge pull requests. Sign up for GitHub Education benefits. If you teach at an academic institution, this is free after verifying your status. This process (as of today) consists of two steps: verify your status and then upgrade your GitHub organization to have the benefits applied. GitHub Education is not necessarily required. GitHub (again, as of today) offers organizations and public repositories free of charge. But if you want private repositories, you need to pay for it - or request the discount. Private repositories are useful so that students do not see each other's work. Open GitHub Classroom , sign-in, and create a new classroom . A classroom can be, for example, your Programming databases 2021 spring course. Classroom per course and per semester The classroom provides you with a level of organization. Create a new classroom each semester, and archive old classrooms. When creating the classroom , you will be offered to create a roster . The problem the roster tries to solve is the mapping of students to repositories. Careful with the roster Identifiers, like names or student ID numbers, are considered sensitive information and should not be published in the roster! In the European Union, the GDPR is quite strict about such matters. Therefore, you should make sure whether using a roster is possible for you. Check the alternative method proposed below. Inside the classroom , create as many assignments as you need. Create one for each homework. Each assignment has a name and a repository name prefix. The repository name prefix will be used when the student's repository is created. Make sure to provide a meaningful name; i.e., \"homework\" will not be enough. Assignment names and repository prefixes A recommended assignment name, for example, is \"Microsoft SQL Server programming\" or \"Homework 1 Java\". The repository name prefix should include: a short prefix to separate these repositories from all others, e.g., \"hw\", the year or semester, and the short name of the assignment. This prefix will be postfixed with the student's GitHub account name, so it will look like this: hw-2021-mssql-tinystar774 . This is how one of my classrooms look like: The assignment will enable you to specify a starter code template repository . This repository will be used to populate the newly created repository for the student. This template repository is your starter code . Finally, note the assignment's invitation URL . This is the link you should communicate to your students. The invitation URL should not be public This URL will enable anyone to create a repository in your organization. Do not publish it on a public website. I have seen a public invitation URL being abused, resulting in the entire GitHub organization being disabled.","title":"Set up GitHub Classroom"},{"location":"using-github/collecting-submissions/#how-does-all-this-help-you","text":"Students need only click the invitation link (see below), and their own personal repository will be created for them. There is no room for error here. Members of the organization will have access to all submission repositories , while students only see their personal repository. You can control access by adding teachers to the organization as members. The starter code is automatically copied into the student's repository. Automating this step is also useful to avoid questions and problems, such as students not finding the download link to the starter code, corrupted downloads, not being able to extract a file due to not having A or B compression tool installed, messing up file names with special characters or spaces in the name, creating an extra unnecessary directory after extracting an archive, etc. (Add your favorite \"how did this happen, really?\" anecdote in here.) You do not need to download students' code or extract it. The source code is available inside a web browser and you can review it with ease. For more details, see Using pull requests .","title":"How does all this help you?"},{"location":"using-github/collecting-submissions/#not-using-a-student-roster","text":"Students get dedicated repositories in GitHub. The problem you will face is to map the repositories to students. The names of the repositories will contain the GitHub user names of students, but that will not be enough. The student roster of GitHub helps this by mapping the student's name to the repository, but it will not change the repository names. Thus it will still be complicated to find the repository for a student. Not to mention the previously noted privacy issues. Instead of the roster, I recommend two other approaches.","title":"Not using a student roster"},{"location":"using-github/collecting-submissions/#option-1-adding-the-student-identifier-to-a-specified-text-file-in-the-repository","text":"Add a dedicated empty text file into the starter code repository into which the students must type their unique ID number. E.g., my university, BME, assigns a so-called Neptun-code to everyone. Thus, I add an empty neptun.txt into the root of the starter code repository , and the assignment instructions tell the students to type their code into this file. There are simple benefits to this solution. First, the mapping of the student with the repository exists inside the repository. If I see a repository, I can check whom it belongs to by checking the file contents. Second, GitHub has extensive search capabilities. I can find the repository of a student by executing a search within the organization, which will match the contents of these text files too. And finally, automation can check the existence of this text file and its content. GitHub has a continuous integration system, called GitHub Actions , enabling us to execute scripts on the student repositories automatically. For example, you can check the text file upon each commit and report an error to the student when there is a problem. An example for such action is available here: https://github.com/akosdudas/ahk-action-neptuncheck . This is a GitHub Action specification, which can be included in a workflow . Customized checking This action requires a specific file name and content. Feel free to reuse it or fork it and create your own!","title":"Option 1: Adding the student identifier to a specified text file in the repository"},{"location":"using-github/collecting-submissions/#option-2-registering-repository-names-in-a-microsoft-form-or-google-forms","text":"You can publish a registration form using Microsoft Forms or Google Forms and ask your students to add their repository URL along with their student ID number. This solution is simple but error-prone if students forget this. Plus, you will not have the search capability as in the previous option.","title":"Option 2: Registering repository names in a Microsoft Form or Google Forms"},{"location":"using-github/collecting-submissions/#classroom-assistant","text":"Once you have the student repositories \"in the cloud,\" i.e., in GitHub, how do you work with them? One option is using pull requests , and the other one is to download them to your machine. I download the repositories for archival purposes at the end of the semester. How do you download hundreds of repositories? GitHub Classroom Assistant is a handy tool that enables mass download of all repositories of a Classroom assignment. I have been using this tool to download up to 250 repositories per assignment. Another way for mass download is scripting with the help of PowerShellForGitHub PowerShell Module . Since all repositories created by Classroom have an identical prefix, you can search for these repositories and clone them all in a script.","title":"Classroom Assistant"},{"location":"using-github/collecting-submissions/#downsides-of-using-github-classroom","text":"GitHub and GitHub Classroom is not a universal solution for all. There are drawbacks and downsides of the techniques presented here. Without going into further details, here is a short list for consideration. Requires a GitHub account. It is free, though, but still asks the student to use a third-party service. Working with git is not always easy. The trivial tasks are simple, but once we get to branching, it tends to get complicated for students who don't have much practice with it. I recommend using good git clients, like GitHub Desktop , and promoting these to students too. There are occasional downtimes at GitHub. Like all cloud services, there are unexpected errors from time to time. In the past years, I have seen students experience intermittent errors dozens of times. It even prohibited us from completing a class once. You need a communication platform (Microsoft Teams, Slack channel, email list, etc.) to let students know when something is not working. Not all of them are experienced enough to recognize a real problem and to know when just a retry is needed. GitHub has its own terminology, like branches and pull requests. But we need assignments and submissions. You have to accept the fact that there is a misalignment here.","title":"Downsides of using GitHub Classroom"},{"location":"using-github/further-automation/","text":"Further automation \u00b6 Using GitHub as a platform allows us to add further automation into the homework submission process. Ahk GitHub Automation \u00b6 Ahk GitHub Automation is a set of tools, open-source, of course, that enable such automation. It consists of: GitHub Monitor : An Azure function written in .NET Core with a http webhook registered as a GitHub Application that manages the workflow of homework submissions. Performs automatic actions on repositories acting as submissions and monitors proper usage of pull requests. Publish Results to PR : A containerized Go application that processes the output of evaluator applications and publishes the results to the student into a pull request, as well as forwarding it to the grade management application. Grade Management : An Azure function written in .NET Core that accepts grades from the other applications and stores them in Azure CosmosDB database. Helps teachers by reducing the administration of submissions and grades. Below you find some features of these apps. For more information, please refer to the description in the following repository: https://github.com/akosdudas/ahk-github-automation . GitHub branch protection rules \u00b6 GitHub pull requests come in handy for seeing the cumulative code changes of the student and for providing feedback. However, it relies on the student performing some mandatory steps: creating a branch and opening a pull request. The more manual steps there are, the bigger the chance of messing something up. The most critical part is working on the right branch in git. If the student pushes content to the wrong branch, it will require manual work to fix it. GitHub has so-called branch protection rules , which can help to prohibit students from doing something wrong. Branch-protection rule for the main/master branch. By protecting the main/master branch with a rule that requires at least one pull request approval, the student cannot add or merge any code into the main/master branch. Therefore, the main/master branch has the initial starter code and the pull request opened by the student will gather all changes made to the code since. Branch-protection rule for all working branches. You should protect all other branches too by prohibiting force push. If a student wants to \"play around\" with the automated evaluation and \"be smart about it\" in any way, these attempts could be hidden by rewriting the past of git using force push. A branch protection rule can prohibit this. Unfortunately, there is no way to set these branch protection rules on students' repositories using GitHub Classroom. But a GitHub App can subscribe to events, such as new branch creation, and add these rules via GitHub's API. Recognizing when a comment is changed \u00b6 The pull request-based process relies on publishing the outcome of the automated evaluation as a comment into the pull request thread. The students have write permission to the repository enabling them to edit comments. So technically, a student could edit the comment added by the automation tool and change the contents. Although the comment would appear as edited , it might not be recognized by the teacher. The solution is to subscribe to the event of comment editing and verifying that students do not touch comments other than their own - or publish a warning when this happens. Accepting a submission and finalizing the grade \u00b6 Once a student submits a homework, the instructor needs to check it and grade it. To reduce the manual work required from the instructor the automatically assigned grades can be recorded in a database. Furthermore, using a \"chatops-like\" command automation can finalize the students submission as follows. By entering the /ahk ok 1.5 2 command: The pull request is approved (signalling both acceptance to the student and allowing merging); The pull request is merged (while this is not really necessary, it is in accordance with software development best prectises); And the final grades/point (the numbers) are recorded in the database too. Using this command simplifies the instructors job. There is no need to manually approve the pull request or to register the grade in Moodle or in Excel.","title":"Further automation"},{"location":"using-github/further-automation/#further-automation","text":"Using GitHub as a platform allows us to add further automation into the homework submission process.","title":"Further automation"},{"location":"using-github/further-automation/#ahk-github-automation","text":"Ahk GitHub Automation is a set of tools, open-source, of course, that enable such automation. It consists of: GitHub Monitor : An Azure function written in .NET Core with a http webhook registered as a GitHub Application that manages the workflow of homework submissions. Performs automatic actions on repositories acting as submissions and monitors proper usage of pull requests. Publish Results to PR : A containerized Go application that processes the output of evaluator applications and publishes the results to the student into a pull request, as well as forwarding it to the grade management application. Grade Management : An Azure function written in .NET Core that accepts grades from the other applications and stores them in Azure CosmosDB database. Helps teachers by reducing the administration of submissions and grades. Below you find some features of these apps. For more information, please refer to the description in the following repository: https://github.com/akosdudas/ahk-github-automation .","title":"Ahk GitHub Automation"},{"location":"using-github/further-automation/#github-branch-protection-rules","text":"GitHub pull requests come in handy for seeing the cumulative code changes of the student and for providing feedback. However, it relies on the student performing some mandatory steps: creating a branch and opening a pull request. The more manual steps there are, the bigger the chance of messing something up. The most critical part is working on the right branch in git. If the student pushes content to the wrong branch, it will require manual work to fix it. GitHub has so-called branch protection rules , which can help to prohibit students from doing something wrong. Branch-protection rule for the main/master branch. By protecting the main/master branch with a rule that requires at least one pull request approval, the student cannot add or merge any code into the main/master branch. Therefore, the main/master branch has the initial starter code and the pull request opened by the student will gather all changes made to the code since. Branch-protection rule for all working branches. You should protect all other branches too by prohibiting force push. If a student wants to \"play around\" with the automated evaluation and \"be smart about it\" in any way, these attempts could be hidden by rewriting the past of git using force push. A branch protection rule can prohibit this. Unfortunately, there is no way to set these branch protection rules on students' repositories using GitHub Classroom. But a GitHub App can subscribe to events, such as new branch creation, and add these rules via GitHub's API.","title":"GitHub branch protection rules"},{"location":"using-github/further-automation/#recognizing-when-a-comment-is-changed","text":"The pull request-based process relies on publishing the outcome of the automated evaluation as a comment into the pull request thread. The students have write permission to the repository enabling them to edit comments. So technically, a student could edit the comment added by the automation tool and change the contents. Although the comment would appear as edited , it might not be recognized by the teacher. The solution is to subscribe to the event of comment editing and verifying that students do not touch comments other than their own - or publish a warning when this happens.","title":"Recognizing when a comment is changed"},{"location":"using-github/further-automation/#accepting-a-submission-and-finalizing-the-grade","text":"Once a student submits a homework, the instructor needs to check it and grade it. To reduce the manual work required from the instructor the automatically assigned grades can be recorded in a database. Furthermore, using a \"chatops-like\" command automation can finalize the students submission as follows. By entering the /ahk ok 1.5 2 command: The pull request is approved (signalling both acceptance to the student and allowing merging); The pull request is merged (while this is not really necessary, it is in accordance with software development best prectises); And the final grades/point (the numbers) are recorded in the database too. Using this command simplifies the instructors job. There is no need to manually approve the pull request or to register the grade in Moodle or in Excel.","title":"Accepting a submission and finalizing the grade"},{"location":"using-github/providing-feedback/","text":"Provide feedback to students \u00b6 During the standard assessment of student work feedback is given once, after the subission deadline. For example, the student hands in a paper and receives marks and a grade afterward. Both the submission and the feedback usually happens in a learning management system, like Moodle. When it comes to source code, giving feedback does not play well with such systems. But the same problem, review of code, has a well-established practice in software development using specific code-review tools. Using pull requests \u00b6 GitHub has a concept called pull requests frequently used in everyday software development. These pull requests can be used to check students' submission. A pull request is, from a technical point of view, a difference between two git branches. If you ask the students to add their code to a dedicated branch, a pull request can combine all the changes into a single view. GitHub has a handy user interface for reviewing the content of a pull request. You can see all the student's effective changes, and you can comment on the source code as feedback: Another added benefit is that pull requests have assignees . The assignee can be the teacher assistant responsible for assessing the work. GitHub provides you with a page that lists PRs assigned to you, so this also serves as a todo-list: Using pull requests for feedback requires you or the student to prepare the repository to have the appropriate branches and open the pull request. There are two options for ensuring these. Option 1: GitHub Classroom's automated feedback pull request \u00b6 GitHub Classroom has a feature to automatically create a feedback pull request . You can enable this option in the assignment's settings. Configuring this will perform the following steps when the repository is created for the student. The source code is imported into the main/master branch. A new branch is created. And a pull request is opened (for merging main/master into the new branch). The student can add commits to the main/master branch. The PR will show the difference between the original state (the starter code) and the current state of main/master providing you with an overview of the student's code changes. You can use the pull request to give the student feedback and comment on the source code. The advantage of this method (compared to the alternative below) is that it is entirely automated. The downside is that the direction of merging is counter-intuitive. The branch created in step 2 is the target branch of the merge in this scenario. In software development, however, such branches (so-called feature branches ) are the source of merge, and the main/master is the target. This merge is not practical if you want to merge the PR at the end (just like it would happen in a software development scenario) because then the final state would be on a branch other than main/master . Option 2: Manually creating a branch \u00b6 The alternative option is to request the student to perform the following manual steps: Create a new branch, e.g., with the name solution . Add commits to this branch. When ready, open a pull request (to merge solution into main/master ) and assign it to the correct teacher. Although there are manual steps here, this option has the following benefits. Follows standard software development practices, i.e., opening a feature branch and working on that branch. Opening and assigning the PR is the act of submission , just like uploading a ZIP/PDF file to a website. This step will appear in the pull request with a timestamp; hence, you can use it to determine if the submission was late. Accepting the student's solution happens by merging the pull request. The final source code gets to the main/master branch, and closing the PR.","title":"Provide feedback to students"},{"location":"using-github/providing-feedback/#provide-feedback-to-students","text":"During the standard assessment of student work feedback is given once, after the subission deadline. For example, the student hands in a paper and receives marks and a grade afterward. Both the submission and the feedback usually happens in a learning management system, like Moodle. When it comes to source code, giving feedback does not play well with such systems. But the same problem, review of code, has a well-established practice in software development using specific code-review tools.","title":"Provide feedback to students"},{"location":"using-github/providing-feedback/#using-pull-requests","text":"GitHub has a concept called pull requests frequently used in everyday software development. These pull requests can be used to check students' submission. A pull request is, from a technical point of view, a difference between two git branches. If you ask the students to add their code to a dedicated branch, a pull request can combine all the changes into a single view. GitHub has a handy user interface for reviewing the content of a pull request. You can see all the student's effective changes, and you can comment on the source code as feedback: Another added benefit is that pull requests have assignees . The assignee can be the teacher assistant responsible for assessing the work. GitHub provides you with a page that lists PRs assigned to you, so this also serves as a todo-list: Using pull requests for feedback requires you or the student to prepare the repository to have the appropriate branches and open the pull request. There are two options for ensuring these.","title":"Using pull requests"},{"location":"using-github/providing-feedback/#option-1-github-classrooms-automated-feedback-pull-request","text":"GitHub Classroom has a feature to automatically create a feedback pull request . You can enable this option in the assignment's settings. Configuring this will perform the following steps when the repository is created for the student. The source code is imported into the main/master branch. A new branch is created. And a pull request is opened (for merging main/master into the new branch). The student can add commits to the main/master branch. The PR will show the difference between the original state (the starter code) and the current state of main/master providing you with an overview of the student's code changes. You can use the pull request to give the student feedback and comment on the source code. The advantage of this method (compared to the alternative below) is that it is entirely automated. The downside is that the direction of merging is counter-intuitive. The branch created in step 2 is the target branch of the merge in this scenario. In software development, however, such branches (so-called feature branches ) are the source of merge, and the main/master is the target. This merge is not practical if you want to merge the PR at the end (just like it would happen in a software development scenario) because then the final state would be on a branch other than main/master .","title":"Option 1: GitHub Classroom's automated feedback pull request"},{"location":"using-github/providing-feedback/#option-2-manually-creating-a-branch","text":"The alternative option is to request the student to perform the following manual steps: Create a new branch, e.g., with the name solution . Add commits to this branch. When ready, open a pull request (to merge solution into main/master ) and assign it to the correct teacher. Although there are manual steps here, this option has the following benefits. Follows standard software development practices, i.e., opening a feature branch and working on that branch. Opening and assigning the PR is the act of submission , just like uploading a ZIP/PDF file to a website. This step will appear in the pull request with a timestamp; hence, you can use it to determine if the submission was late. Accepting the student's solution happens by merging the pull request. The final source code gets to the main/master branch, and closing the PR.","title":"Option 2: Manually creating a branch"},{"location":"using-github/publishing-specification/","text":"Publising the assignment \u00b6 Are you uploading the homework specification as a PDF or ZIP to a university webpage? Making changes to such documents is laborious and error-prone: you need to edit the document, export it, and upload it. If you want to make this easier, then you might try an alternative: use GitHub and GitHub Pages. Starter code in a repository \u00b6 The stater code is a set of files that the student needs to download to start working on the homework. What better way to store and publish software source code than a git repository? Create a new repository in the GitHub organization for each homework assignment. The repository name should clearly indicate that it contains starter code, e.g., call it hw-mssql-starter . GitHub has a useful feature called template repositories , which makes it easy to create a new repository by copying the contents from the template. Check out a sample starter code repository here: https://github.com/bmeviauac01/gyakorlat-rest-kiindulo . GitHub Pages website \u00b6 GitHub Pages publishes static websites from git repositories. While it might not be the first thought of many to use git, a version control system, for tasks typically performed in Microsoft Word, using git and static websites has many advantages. Requires tools that are convenient for a software developer. We use git daily. And we all have our favorite text editors, such as Notepad++ or Visual Studio Code. Has support for versioning. Yes, class materials should be versioned, but keeping older versions lying around with obscure file names, like v1 , v2019-last , or v2021 NEW is not professional. Making the documentation open-source allows students to propose changes, e.g., to fix typos. It also promotes the open-source initiative. Automations take care of publishing a new version. While a Word document is convenient for editing, publishing often requires saving the content as a PDF and then uploading it somewhere. When using GitHub Pages, these can be automated using continuous integration services. Check out a sample repository here: https://github.com/bmeviauac01/datadriven-en is the source code and the published website is available at https://bmeviauac01.github.io/datadriven-en/ . The steps for using GitHub pages: Create a new repository. If you need a single website in the organization, you can create a repository with the name organizationname.github.io published at the address https://organizationname.github.io . Or you may give a different name to the repository, such as homeworks , in which case the address will be https://organizationname.github.io/homeworks . Create the website content. There are many ways to do this. Use the source of this repository (upper right corner) to check how this one is built using MkDocs , MkDocs for Material , and GitHub Pages action . If you need to make a change to the website, edit the source, commit, and finally, push. The standard software development workflow in action, only, this time, for website content. Other platforms GitLab Pages and BitBucket have similar offerings. Public repository The website can be published for public access from a private repository. By publising the website and the code publicly you can get students engadge. E.g., if they find a typo, they can propose a change to fix it. You need to make the repository public to enable this. Alternative option: using cloud-based documents \u00b6 If you don't want to publish the assignment to the whole world as a website, there is still another way to eliminate PDF files: use Microsoft 365 or Google Docs. You only need to edit the file on your computer or in a web browser, and the \"publishing\" part is automated. By publishing a read-only link to the document, students can always access the latest version while you can quickly make edits to the document.","title":"Publising the assignment"},{"location":"using-github/publishing-specification/#publising-the-assignment","text":"Are you uploading the homework specification as a PDF or ZIP to a university webpage? Making changes to such documents is laborious and error-prone: you need to edit the document, export it, and upload it. If you want to make this easier, then you might try an alternative: use GitHub and GitHub Pages.","title":"Publising the assignment"},{"location":"using-github/publishing-specification/#starter-code-in-a-repository","text":"The stater code is a set of files that the student needs to download to start working on the homework. What better way to store and publish software source code than a git repository? Create a new repository in the GitHub organization for each homework assignment. The repository name should clearly indicate that it contains starter code, e.g., call it hw-mssql-starter . GitHub has a useful feature called template repositories , which makes it easy to create a new repository by copying the contents from the template. Check out a sample starter code repository here: https://github.com/bmeviauac01/gyakorlat-rest-kiindulo .","title":"Starter code in a repository"},{"location":"using-github/publishing-specification/#github-pages-website","text":"GitHub Pages publishes static websites from git repositories. While it might not be the first thought of many to use git, a version control system, for tasks typically performed in Microsoft Word, using git and static websites has many advantages. Requires tools that are convenient for a software developer. We use git daily. And we all have our favorite text editors, such as Notepad++ or Visual Studio Code. Has support for versioning. Yes, class materials should be versioned, but keeping older versions lying around with obscure file names, like v1 , v2019-last , or v2021 NEW is not professional. Making the documentation open-source allows students to propose changes, e.g., to fix typos. It also promotes the open-source initiative. Automations take care of publishing a new version. While a Word document is convenient for editing, publishing often requires saving the content as a PDF and then uploading it somewhere. When using GitHub Pages, these can be automated using continuous integration services. Check out a sample repository here: https://github.com/bmeviauac01/datadriven-en is the source code and the published website is available at https://bmeviauac01.github.io/datadriven-en/ . The steps for using GitHub pages: Create a new repository. If you need a single website in the organization, you can create a repository with the name organizationname.github.io published at the address https://organizationname.github.io . Or you may give a different name to the repository, such as homeworks , in which case the address will be https://organizationname.github.io/homeworks . Create the website content. There are many ways to do this. Use the source of this repository (upper right corner) to check how this one is built using MkDocs , MkDocs for Material , and GitHub Pages action . If you need to make a change to the website, edit the source, commit, and finally, push. The standard software development workflow in action, only, this time, for website content. Other platforms GitLab Pages and BitBucket have similar offerings. Public repository The website can be published for public access from a private repository. By publising the website and the code publicly you can get students engadge. E.g., if they find a typo, they can propose a change to fix it. You need to make the repository public to enable this.","title":"GitHub Pages website"},{"location":"using-github/publishing-specification/#alternative-option-using-cloud-based-documents","text":"If you don't want to publish the assignment to the whole world as a website, there is still another way to eliminate PDF files: use Microsoft 365 or Google Docs. You only need to edit the file on your computer or in a web browser, and the \"publishing\" part is automated. By publishing a read-only link to the document, students can always access the latest version while you can quickly make edits to the document.","title":"Alternative option: using cloud-based documents"}]}